<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Origin + Unicode Detector</title>
  <style>
    body {
      background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 40px 20px;
      min-height: 100vh;
    }
    h1 {
      font-size: 2em;
      margin-bottom: 1em;
    }
    #results, #aiResults {
      margin-bottom: 1em;
      font-size: 1.2em;
      white-space: pre-wrap;
    }
    #usageCounter {
      margin-bottom: 1em;
      font-size: 1em;
      color: #1abc9c;
    }
    #ipInfo {
      margin-bottom: 1em;
      font-size: 0.9em;
      color: #95a5a6;
    }
    textarea {
      width: 90%;
      max-width: 800px;
      height: 300px;
      padding: 16px;
      border-radius: 8px;
      font-size: 1em;
      font-family: monospace;
      resize: vertical;
      background-color: #1e2a38;
      color: #ffffff;
      border: 1px solid #ccc;
    }
    .button {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #1abc9c;
      color: #fff;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 1em;
    }
    .button:hover {
      background-color: #16a085;
    }
    #code {
      margin-bottom: 10px;
      padding: 10px;
      font-size: 1em;
      border-radius: 8px;
      border: 1px solid #ccc;
      background-color: #1e2a38;
      color: #fff;
      width: 90%;
      max-width: 800px;
    }
    .disabled {
      background-color: #7f8c8d !important;
      cursor: not-allowed !important;
    }
  </style>
</head>
<body>
  <h1>Hidden Unicode + AI Origin Detector</h1>
  <div id="ipInfo">Getting IP info...</div>
  <div id="usageCounter">Daily uses remaining: <span id="remainingUses">Loading...</span></div>
  <div id="results">Paste something and click Detect...</div>
  <div id="aiResults"></div>
  <input type="password" id="code" placeholder="Enter secret code (optional)">
  <textarea id="input" placeholder="Paste your code, message, or text here..."></textarea>
  <button class="button" id="detectButton">Detect</button>

  <script>
    let userIP = null;
    let userCountry = null;

    document.getElementById("detectButton").addEventListener("click", runDetection);

    // Get user's IP and location on page load with multiple fallbacks
    async function getUserInfo() {
      const ipServices = [
        'https://api.ipify.org?format=json',
        'https://ipapi.co/json/',
        'https://ipinfo.io/json',
        'https://api.ip.sb/geoip'
      ];

      for (const service of ipServices) {
        try {
          const response = await fetch(service, { timeout: 5000 });
          if (!response.ok) continue;
          
          const data = await response.json();
          
          // Different services have different field names
          userIP = data.ip || data.query || data.address;
          userCountry = data.country_name || data.country || data.region || 'Unknown';
          
          if (userIP) {
            document.getElementById("ipInfo").innerText = `IP: ${userIP} ‚Ä¢ Location: ${userCountry}`;
            updateUsageDisplay();
            return;
          }
        } catch (error) {
          console.log(`Failed to get IP from ${service}:`, error);
          continue;
        }
      }

      // If all services fail, generate a browser fingerprint as fallback
      console.log('All IP services failed, using browser fingerprint');
      userIP = generateBrowserFingerprint();
      userCountry = 'Unknown';
      document.getElementById("ipInfo").innerText = `Using browser fingerprint ‚Ä¢ Offline mode`;
      updateUsageDisplay();
    }

    // Generate a unique browser fingerprint as backup
    function generateBrowserFingerprint() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('Browser fingerprint', 2, 2);
      
      const fingerprint = [
        navigator.userAgent,
        navigator.language,
        screen.width + 'x' + screen.height,
        new Date().getTimezoneOffset(),
        canvas.toDataURL()
      ].join('|');
      
      // Create a simple hash
      let hash = 0;
      for (let i = 0; i < fingerprint.length; i++) {
        const char = fingerprint.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      
      return 'fp_' + Math.abs(hash).toString(16);
    }

    const webAppUrl = 'https://script.google.com/macros/s/AKfycbxHdkyMhqIwSVovTejIRCw92AqWJAKyE8H3UDJ4N4c0HtLk74bP8XjJPVHYhupkDzKa/exec';

    async function getIPUsage() {
      if (!userIP) return 0;
      try {
        const response = await fetch(`${webAppUrl}?action=get&ip=${encodeURIComponent(userIP)}&date=${new Date().toISOString().split("T")[0]}`);
        if (!response.ok) throw new Error("Failed to fetch usage data");
        const data = await response.json();
        console.log('getIPUsage response:', data);
        return data.count || 0;
      } catch (error) {
        console.error("Error in getIPUsage:", error);
        return 0;
      }
    }

    // FIXED: Use GET request with URL parameters instead of POST to avoid CORS preflight
    async function postIPUsage(newCount) {
      if (!userIP) return;
      try {
        // Use GET request with parameters instead of POST to avoid CORS preflight
        const params = new URLSearchParams({
          action: 'update',
          ip: userIP,
          date: new Date().toISOString().split("T")[0],
          count: newCount,
          country: userCountry || 'Unknown'
        });
        
        console.log('Sending update request:', params.toString());
        const response = await fetch(`${webAppUrl}?${params.toString()}`);
        if (!response.ok) throw new Error("Failed to update usage data");
        const result = await response.json();
        console.log('postIPUsage response:', result);
        return result;
      } catch (error) {
        console.error("Error in postIPUsage:", error);
      }
    }

    async function updateUsageDisplay() {
      const count = await getIPUsage();
      const remaining = Math.max(0, 3 - count);
      document.getElementById("remainingUses").innerText = remaining;
      console.log(`Usage display updated - ID: ${userIP}, Count: ${count}, Remaining: ${remaining}`);
    }

    async function runDetection() {
      const input = document.getElementById("input").value;
      const codeInput = document.getElementById("code").value.trim();
      
      if (!input.trim()) {
        alert("‚ö†Ô∏è Please enter some text to analyze!");
        return;
      }
      
      // Obfuscated secret codes (base64 encoded)
      const secretCodes = {
        'bGV0bWVpbjQy': { name: 'Admin', limit: 999 }, // letmein42 - unlimited
        'R2FpbDE=': { name: 'Gail', limit: 5 },        // Gail1 - 5 uses
        'QW5kcmV3MQ==': { name: 'Andrew', limit: 5 }   // Andrew1 - 5 uses
      };
      
      // Check if code matches any secret
      const encodedInput = btoa(codeInput);
      const userInfo = secretCodes[encodedInput];
      const isSpecialUser = !!userInfo;
      
      // Get current usage before running detection
      let currentCount = await getIPUsage();
      console.log(`Current count before increment: ${currentCount}`);
      
      // Determine usage limit based on user
      let usageLimit = 3; // Default for regular users
      if (isSpecialUser) {
        usageLimit = userInfo.limit;
        
        // Show personalized greeting for secret codes
        if (codeInput) {
          if (userInfo.name === 'Admin') {
            alert("üîì Admin access granted! Unlimited usage activated.");
          } else {
            alert(`üëã Hello ${userInfo.name}! Welcome back. You have ${userInfo.limit} daily uses.`);
          }
        }
      }
      
      // Check limit based on user type
      if (currentCount >= usageLimit) {
        if (isSpecialUser && userInfo.name !== 'Admin') {
          alert(`üö´ You've hit your ${usageLimit} daily uses. Come back tomorrow!`);
        } else if (!isSpecialUser) {
          alert("üö´ You've hit your 3 daily uses. Come back tomorrow or enter a secret code.");
        }
        return;
      }
      
      // Disable button during processing
      const detectBtn = document.getElementById("detectButton");
      detectBtn.disabled = true;
      detectBtn.classList.add("disabled");
      detectBtn.innerText = "Processing...";
      
      // Increment counter for all users (except admin with unlimited)
      if (!isSpecialUser || userInfo.name !== 'Admin') {
        const newCount = currentCount + 1;
        console.log(`Incrementing count from ${currentCount} to ${newCount}`);
        
        const updateResult = await postIPUsage(newCount);
        console.log('Update result:', updateResult);
        
        // Wait a moment for the database to update, then refresh display
        setTimeout(() => {
          updateUsageDisplay();
        }, 1000);
      }
      
      // Run detection logic
      const unicodeResults = detectInvisibleUnicode(input);
      document.getElementById("results").innerText = unicodeResults.join("\n");
      
      try {
        const aiCheck = detectAIStyle(input);
        document.getElementById("aiResults").innerText = `${aiCheck.verdict}\n\nDetails:\n${aiCheck.clues.join("\n")}`;
      } catch (error) {
        document.getElementById("aiResults").innerText = `‚ùå Error in AI detection: ${error.message}`;
      }
      
      // Re-enable button
      detectBtn.disabled = false;
      detectBtn.classList.remove("disabled");
      detectBtn.innerText = "Detect";
    }

    function detectInvisibleUnicode(text) {
      const invisibleChars = [
        { char: "\u200B", label: "Zero-Width Space (U+200B)" },
        { char: "\u200C", label: "Zero-Width Non-Joiner (U+200C)" },
        { char: "\u200D", label: "Zero-Width Joiner (U+200D)" },
        { char: "\u2060", label: "Word Joiner (U+2060)" },
        { char: "\uFEFF", label: "Zero Width No-Break Space (U+FEFF)" },
        { char: "\u202E", label: "Right-to-Left Override (U+202E)" },
        { char: "\u00A0", label: "Non-breaking Space (U+00A0)" }
      ];

      const suspiciousEmojis = [
        // AI Self-Reference & Tech
        { emoji: "ü§ñ", label: "Robot emoji (AI self-reference)" },
        { emoji: "üß†", label: "Brain emoji (AI intelligence branding)" },
        { emoji: "‚ö°", label: "Lightning emoji (fast processing)" },
        { emoji: "üîß", label: "Wrench emoji (technical fixes)" },
        { emoji: "‚öôÔ∏è", label: "Gear emoji (mechanical processing)" },
        { emoji: "üíª", label: "Laptop emoji (computing)" },
        { emoji: "üñ•Ô∏è", label: "Desktop computer emoji" },
        { emoji: "üíæ", label: "Floppy disk (data storage)" },
        { emoji: "üíø", label: "CD emoji (data storage)" },
        { emoji: "üíΩ", label: "Disk emoji (data storage)" },
        { emoji: "üîå", label: "Plug emoji (connectivity)" },
        { emoji: "üì°", label: "Satellite emoji (data transmission)" },
        
        // AI Communication Patterns
        { emoji: "‚úÖ", label: "Green check emoji (AI confirmation style)" },
        { emoji: "‚ö†Ô∏è", label: "Warning emoji (AI alert style)" },
        { emoji: "üö®", label: "Red siren emoji (urgent AI notifications)" },
        { emoji: "üö´", label: "Prohibited emoji (AI blocking/denial)" },
        { emoji: "‚ùå", label: "Cross mark (AI rejection/error)" },
        { emoji: "üõë", label: "Stop sign emoji (AI warnings)" },
        { emoji: "ü§î", label: "Thinking face emoji (AI pondering)" },
        { emoji: "ü§®", label: "Raised eyebrow emoji (AI suspicion)" },
        { emoji: "üí°", label: "Lightbulb emoji (AI insights)" },
        { emoji: "üìù", label: "Memo emoji (AI documentation style)" },
        { emoji: "üí≠", label: "Thought bubble (AI processing)" },
        { emoji: "üîç", label: "Magnifying glass (AI investigation)" },
        { emoji: "üîé", label: "Right-pointing magnifying glass" },
        
        // AI Aesthetic Choices
        { emoji: "üåà", label: "Rainbow emoji (decorative gradients)" },
        { emoji: "‚ú®", label: "Sparkles emoji (AI embellishment)" },
        { emoji: "üé®", label: "Palette emoji (design elements)" },
        { emoji: "üì¶", label: "Package emoji (modular AI thinking)" },
        { emoji: "üñãÔ∏è", label: "Pen emoji (writing style indicators)" },
        { emoji: "üéûÔ∏è", label: "Film emoji (animation descriptions)" },
        { emoji: "üåü", label: "Star emoji (highlighting points)" },
        { emoji: "üöÄ", label: "Rocket emoji (progress/advancement)" },
        
        // Professional/Verdict Style
        { emoji: "üßë‚Äçüíª", label: "Technologist emoji (AI verdicts)" },
        { emoji: "üë®‚Äç‚öñÔ∏è", label: "Judge emoji (AI conclusions)" },
        { emoji: "üë©‚Äç‚öñÔ∏è", label: "Female judge emoji (AI conclusions)" },
        { emoji: "üìä", label: "Chart emoji (data analysis)" },
        { emoji: "üìà", label: "Trending up chart" },
        { emoji: "üìâ", label: "Trending down chart" },
        { emoji: "üéØ", label: "Target emoji (precision)" },
        { emoji: "üèÜ", label: "Trophy emoji (achievements)" },
        
        // Rarely Used by Humans
        { emoji: "üîÄ", label: "Shuffle emoji (randomization)" },
        { emoji: "‚öñÔ∏è", label: "Scales emoji (weighing options)" },
        { emoji: "üß¨", label: "DNA emoji (complex analysis)" },
        { emoji: "üìê", label: "Triangular ruler (precision)" },
        { emoji: "üìè", label: "Straight ruler (measurement)" },
        { emoji: "‚ôæÔ∏è", label: "Infinity emoji (mathematical concepts)" },
        { emoji: "üî∫", label: "Red triangle up (directional)" },
        { emoji: "üîª", label: "Red triangle down (directional)" },
        { emoji: "‚≠ï", label: "Red circle (emphasis)" },
        { emoji: "üî¨", label: "Microscope (analysis)" },
        { emoji: "‚öõÔ∏è", label: "Atom symbol (algorithms/science)" },
        { emoji: "üßÆ", label: "Abacus (calculations)" },
        
        // Mathematical Operations
        { emoji: "‚ûï", label: "Plus sign (mathematical)" },
        { emoji: "‚ûñ", label: "Minus sign (mathematical)" },
        { emoji: "‚úñÔ∏è", label: "Multiplication sign" },
        { emoji: "‚ûó", label: "Division sign" },
        
        // Process/Status Indicators
        { emoji: "üîÑ", label: "Counterclockwise arrows (processing)" },
        { emoji: "üîÉ", label: "Clockwise vertical arrows (updating)" },
        { emoji: "‚è≥", label: "Hourglass (working on something)" },
        { emoji: "‚åõ", label: "Hourglass done (completed)" },
        { emoji: "üîó", label: "Link symbol (connections)" },
        { emoji: "üìã", label: "Clipboard (lists/organization)" },
        { emoji: "üõ†Ô∏è", label: "Hammer and wrench (tools/fixing)" },
        
        // Additional AI-Style Emojis
        { emoji: "üé™", label: "Circus tent (playful AI responses)" },
        { emoji: "üåç", label: "Earth globe (global/world topics)" },
        { emoji: "üì±", label: "Mobile phone (apps/mobile)" },
        { emoji: "üéµ", label: "Musical note (music-related AI)" },
        { emoji: "üì∏", label: "Camera (images/visual content)" },
        { emoji: "üòÖ", label: "Grinning with sweat (AI embarrassment)" },
        { emoji: "üòå", label: "Relieved face (AI satisfaction)" },
        { emoji: "üôÉ", label: "Upside-down face (playful AI)" },
        { emoji: "üòÑ", label: "Grinning face (AI enthusiasm)" },
        { emoji: "üëç", label: "Thumbs up (AI acknowledgment)" },
        { emoji: "‚ùì", label: "Question mark (AI queries)" },
        { emoji: "‚ùó", label: "Exclamation mark (AI emphasis)" }
      ];

      const findings = [];

      invisibleChars.forEach(({ char, label }) => {
        const count = (text.match(new RegExp(char.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g")) || []).length;
        if (count > 0) {
          findings.push(`‚ö†Ô∏è Found ${count} instance(s) of ${label}`);
        }
      });

      suspiciousEmojis.forEach(({ emoji, label }) => {
        const count = (text.match(new RegExp(emoji.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g")) || []).length;
        if (count > 0) {
          findings.push(`ü§® Found ${count} instance(s) of suspicious emoji: ${label}`);
        }
      });

      return findings.length ? findings : ["‚úÖ No hidden Unicode characters or suspicious emojis found"];
    }

    function detectAIStyle(text) {
      let score = 0;
      const clues = [];
      
      try {
        // Basic test
        clues.push("üß™ AI detection function is running");
        
        // AI-Specific Programming Patterns
        
        // MARK comments (extremely AI-characteristic)
        const markComments = (text.match(/\/\/ MARK: -/g) || []).length;
        if (markComments > 0) {
          score += 3;
          clues.push(`üìç MARK comments (${markComments} instances) - highly AI characteristic`);
        }
        
        // Excessive organization comments
        const organizationComments = (text.match(/\/\/ MARK:|enum \w+Config|final class \w+Manager/g) || []).length;
        if (organizationComments > 2) {
          score += 2;
          clues.push(`üóÇÔ∏è Over-organized code structure (${organizationComments} instances)`);
        }
        
        // AI's favorite Swift patterns
        if (text.includes("@StateObject") && text.includes("@ObservedObject")) {
          score += 2;
          clues.push("üì± SwiftUI state management pattern combo");
        }
        
        if (text.includes("static let") && text.includes("static func")) {
          score += 1;
          clues.push("‚ö° Heavy static usage (AI prefers static)");
        }
        
        // Enum with static values (AI loves this pattern)
        if (text.includes("enum") && text.includes("static let")) {
          score += 2;
          clues.push("üîß Enum + static configuration pattern");
        }
        
        // AI Resume/Professional Document Patterns
        
        // AI's favorite resume buzzwords
        const resumeBuzzwords = (text.match(/dedicated|passionate|expert|proficient|exceptional|comprehensive|seamless|spearheading|cross-functional|innovative|strategic|optimize|streamline|enhance|leverage|align|foster|extensive|proactive|continuous/gi) || []).length;
        if (resumeBuzzwords > 8) {
          score += 3;
          clues.push(`üíº AI resume buzzword overload (${resumeBuzzwords} instances)`);
        }
        
        // AI bullet point patterns
        const bulletStartPatterns = (text.match(/^[\s]*‚Ä¢[\s]*(Recognized|Skilled|Proactive|Creator|Experienced|Responsible|Leading|Providing|Developing|Ensuring)/gm) || []).length;
        if (bulletStartPatterns > 3) {
          score += 2;
          clues.push(`üìù AI bullet point formula (${bulletStartPatterns} formulaic starts)`);
        }
        
        // AI's favorite professional phrases
        const aiProfessionalPhrases = (text.match(/passion for|aligning.*with|business needs|cross-functional teams|seamless.*integrations?|continuous improvement|staying up-to-date|emerging technologies|process improvement|expert-level guidance|comprehensive training/gi) || []).length;
        if (aiProfessionalPhrases > 4) {
          score += 3;
          clues.push(`ü§ñ AI professional phrase patterns (${aiProfessionalPhrases} instances)`);
        }
        
        // AI resume structure patterns
        if (text.includes("SUMMARY") && text.includes("EXPERIENCE") && text.includes("EDUCATION")) {
          score += 1;
          clues.push("üìã Standard AI resume structure");
        }
        
        // AI loves these specific combinations
        if (text.includes("troubleshooting") && text.includes("performance tuning")) {
          score += 2;
          clues.push("üîß AI's favorite IT skill combo");
        }
        
        // AI redundancy patterns
        const redundantSkills = text.includes("Siebel") && (text.match(/Siebel/g) || []).length > 8;
        if (redundantSkills) {
          score += 2;
          clues.push("üîÑ Excessive keyword repetition (SEO stuffing)");
        }
        
        // AI's formal language overuse
        const formalLanguage = (text.match(/\b(utilizing|facilitating|implementing|administering|coordinating|collaborating|architecting|spearheading)\b/gi) || []).length;
        if (formalLanguage > 5) {
          score += 2;
          clues.push(`üé© Overly formal business language (${formalLanguage} instances)`);
        }
        
        // AI loves present participle overuse
        const ingWords = (text.match(/\b\w+ing\b/g) || []).length;
        if (ingWords > 15) {
          score += 1;
          clues.push(`‚ö° Excessive -ing words (${ingWords} instances)`);
        }
        
        // AI's date format preference
        if (text.includes("‚Äì") && text.includes("Current")) {
          score += 1;
          clues.push("üìÖ AI date formatting pattern");
        }
        
        // Generic variable names (AI favorites)
        const genericVars = (text.match(/\b(width|height|size|radius|position|velocity|speed|count|rate|factor)\b/g) || []).length;
        if (genericVars > 10) {
          score += 2;
          clues.push(`üè∑Ô∏è Generic variable names (${genericVars} instances)`);
        }
        
        // Mathematical precision (AI loves exact values)
        const preciseNumbers = (text.match(/0\.\d{2,}/g) || []).length;
        if (preciseNumbers > 5) {
          score += 1;
          clues.push(`üî¢ Precise decimal values (${preciseNumbers} instances)`);
        }
        
        // AI's favorite guard statements
        const guardStatements = (text.match(/guard.*else.*return/g) || []).length;
        if (guardStatements > 2) {
          score += 1;
          clues.push(`üõ°Ô∏è Multiple guard statements (${guardStatements} instances)`);
        }
        
        // Computed properties (AI overuses these)
        const computedProps = (text.match(/var \w+: \w+ \{[^}]*\}/g) || []).length;
        if (computedProps > 3) {
          score += 1;
          clues.push(`üíª Multiple computed properties (${computedProps} instances)`);
        }
        
        // AI's color patterns
        if (text.includes("Color(red:") || text.includes("Color(hue:")) {
          score += 1;
          clues.push("üé® Programmatic color generation");
        }
        
        // Canvas usage (AI loves Canvas for games)
        if (text.includes("Canvas {") && text.includes("ctx.fill")) {
          score += 2;
          clues.push("üñºÔ∏è SwiftUI Canvas usage (AI game pattern)");
        }
        
        // AI's timer pattern
        if (text.includes("Timer.publish") && text.includes("autoconnect")) {
          score += 2;
          clues.push("‚è∞ AI's favorite timer pattern");
        }
        
        // Perfect spacing/alignment obsession
        if (text.includes("Spacer()") && text.includes(".padding(")) {
          score += 1;
          clues.push("üìê Spacing/padding perfectionism");
        }
        
        // Previous simple checks
        if (text.includes("gradient")) {
          score += 1;
          clues.push("üåà Contains gradient styling");
        }
        
        if (text.includes("button")) {
          score += 1;
          clues.push("üîò Contains button elements");
        }
        
        // Test emoji detection
        if (text.includes("üö´")) {
          score += 2;
          clues.push("üö´ Contains prohibited emoji (AI pattern)");
        }
        
        if (text.includes("‚úÖ")) {
          score += 2;
          clues.push("‚úÖ Contains check mark emoji (AI pattern)");
        }
        
        // Simple phrase detection
        if (text.toLowerCase().includes("daily uses")) {
          score += 2;
          clues.push("üìÖ Contains 'daily uses' phrase (AI limit language)");
        }
        
        if (text.toLowerCase().includes("come back tomorrow")) {
          score += 2;
          clues.push("‚è∞ Contains 'come back tomorrow' (AI scheduling language)");
        }
        
        // File organization patterns
        const structCount = (text.match(/struct \w+:/g) || []).length;
        const classCount = (text.match(/final class \w+:/g) || []).length;
        const enumCount = (text.match(/enum \w+/g) || []).length;
        
        if (structCount + classCount + enumCount > 8) {
          score += 2;
          clues.push(`üèóÔ∏è Over-structured code (${structCount + classCount + enumCount} types)`);
        }
        
        // AI loves extension organization
        if (text.includes("extension") && markComments > 0) {
          score += 1;
          clues.push("üìÇ Extension + MARK organization");
        }
        
        console.log(`Debug: Score=${score}, Clues=${clues.length}`);
        
      } catch (error) {
        console.error("Error in detectAIStyle:", error);
        clues.push(`‚ùå Error: ${error.message}`);
      }
      
      return {
        score,
        clues,
        verdict: score >= 10 ? "ü§ñ Extremely likely AI-generated" : score >= 6 ? "ü§ñ Highly likely AI-generated" : score >= 4 ? "ü§î Probably AI-assisted" : score >= 2 ? "üßë‚Äçü§ñ Possibly AI-influenced" : "üßë‚Äçüíª Likely human-written"
      };
    }

    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', getUserInfo);
  </script>
</body>
</html>
